using System.Collections.Generic;
using System;
using csPrototype.src.Basil;
 
namespace SineVita.Muguet
{
    public static class HarmonyHelper
    {
        // basic comonly used cache data for debugging stage.
        public static string[] MidiPitchIntervalName = new string[] {
            // Populate with actual interval names
            "R", "m2", "M2", "m3", "M3", "P4", "T1", "P5", "m6", "M6", "m7", "M7",
            "O1", "m9", "M9", "m10", "M10", "P11", "T2", "P12", "m13", "M13", "m14", "M14",
            "O2", "m16", "M16", "m17", "M17", "P18", "T3", "P19", "m20", "M20", "m21", "M21",
            "O3", "m23", "M23", "m24", "M24", "P25", "T4", "P26", "m27", "M27", "m28", "M28",
            "O4"
        };
        public static string[] MidiNotesValue = new string[] {
            "C", "C#/Db", "D", "D#/Eb", "E", "F", "F#/Gb", "G", "G#/Ab", "A", "A#/Bb", "B"
        };

        // micellaneous functions
        public static (int reducedNumerator, int reducedDenominator) ReduceFraction(int numerator, int denominator)
        {
            // Nested method to find the greatest common divisor (GCD) recursively
            int GcdRecursive(int a, int b)
            {
                if (b == 0)
                {
                    return a;
                }
                return GcdRecursive(b, a % b);
            }

            int gcd = GcdRecursive(numerator, denominator);
            int reducedNumerator = numerator / gcd;
            int reducedDenominator = denominator / gcd;

            return (reducedNumerator, reducedDenominator);
        }
        public static Pitch[] SortPitchArray(Pitch[] pitchArray)
        {
            int n = pitchArray.Length;
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n - i - 1; j++)
                {
                    if (pitchArray[j].Frequency > pitchArray[j + 1].Frequency)
                    {
                        // Swap
                        var temp = pitchArray[j];
                        pitchArray[j] = pitchArray[j + 1];
                        pitchArray[j + 1] = temp;
                    }
                }
            }
            return pitchArray;
        }
        
        // Midi, frequency and note name conversion methods
        public static float CalculateHtzToMidi(double htz, int rounding = 0)
        {
            return (float)Math.Round(69 + 12 * Math.Log2(htz / 440), rounding);
        }
        public static float CalculateMidiToHtz(int midi, int rounding = 3)
        {
            return (float)Math.Round(440 * Math.Pow(2, (midi - 69) / 12.0), rounding);
        }
        public static string ConvertMidiToIntervalName(int midiValue)  // Incomplete conversion function
        {
            return MidiPitchIntervalName[midiValue % 12 + (int)Math.Floor((double)MidiPitchIntervalName.Length / 12) * 12 - 12];
        }
        public static int ConvertNoteNameToMidi(string noteName) // does not have lookup equiv
        {
            int index = -100000;
            string[] junkList = { "/", "#", "b", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };
            string octave = noteName;

            foreach (var junk in junkList)
            {
                if (octave.Contains(junk))
                {
                    octave = octave.Replace(junk, string.Empty);
                }
            }

            for (int i = 0; i < 12; i++)
            {
                if (noteName.Contains(MidiNotesValue[i]))
                {
                    index = i;
                    break;
                }
            }

            return index + int.Parse(octave) * 12 + 12;
        }
        public static string ConvertMidiToNoteName(int midiValue) // does not have lookup equiv
        {
            return $"{MidiNotesValue[midiValue % 12]}{Math.Floor((double)midiValue / 12) - 1}";
        }
        public static float CalculateHtzToMidiInterval(double htz, int rounding = 0)
        {
            return (float)Math.Round(12 * Math.Log2(htz), rounding);
        }
        public static string ConvertHtzToNoteName(double htz, int rounding = 0) {
            return ConvertMidiToNoteName((int)CalculateHtzToMidi(htz, rounding : rounding));
        }


        public static float LookUpHtzToMidi(double htz, int rounding = 0) // Incomplete LookupTable
        {
            if ((htz > 1) && (htz < 32768))
            {
                return 0.0f; // Look up from a table - incomplete
            }
            else
            {
                return CalculateHtzToMidi(htz, rounding);
            } ;
        }
        public static float LookUpMidiToHtz(int midi, int rounding = 3) // Incomplete LookupTable
        {
            if ((midi > 0) && (midi <= 128))
            {
                return 0.0f; // Look up from a table - incomplete 
            }
            else
            {
                return CalculateMidiToHtz(midi, rounding);
            }           
        }
        public static string LookUpMidiToIntervalName(int midiValue)
        {
            if (midiValue >= MidiPitchIntervalName.Length)
            {
                return ConvertMidiToIntervalName(midiValue);
            }
            else
            {
                return MidiPitchIntervalName[midiValue];
            }
        }
        public static string LookUpHtzToIntervalName(double htz, int rounding = 0) {
            return LookUpMidiToIntervalName((int)CalculateHtzToMidi(htz, rounding : rounding));
        }
        // Pitch -> Pitch Interval

        public static PitchInterval CreatePitchInterval(Pitch pitch1, Pitch pitch2, PitchType tagetIntervalType = PitchType.Any, bool absoluteInterval = false) // pitch 1 is always lower than pitch 2
        {
            //BasilMuguet.Log($"Creating Pitchinterval between {ConvertHtzToNoteName(pitch1.Frequency)} and {ConvertHtzToNoteName(pitch2.Frequency)}");
            // Set up higher and lower pitches
            Pitch higherPitch, lowerPitch;
            if (absoluteInterval) {
                if (pitch1.Frequency > pitch2.Frequency) {
                    higherPitch = pitch1;
                    lowerPitch = pitch2;
                }
                else {
                    higherPitch = pitch2;
                    lowerPitch = pitch1;
                }
            } 
            else {
                lowerPitch = pitch1;
                higherPitch = pitch2;
            }
            
            // working capital
            double frequencyRatio = higherPitch.Frequency / lowerPitch.Frequency;
            int centDifference = higherPitch.CentDifference - lowerPitch.CentDifference;
            if (tagetIntervalType == PitchType.Any) {tagetIntervalType = lowerPitch.Type;}

            // Check if pitch types are the same
            if (lowerPitch.Type == higherPitch.Type && tagetIntervalType == higherPitch.Type) {
                if (tagetIntervalType == PitchType.JustIntonation) {
                    var justRatio = new[] {
                        ((JustIntonalPitch)higherPitch).JustFrequency.Item1 * ((JustIntonalPitch)lowerPitch).JustFrequency.Item2,
                        ((JustIntonalPitch)higherPitch).JustFrequency.Item2 * ((JustIntonalPitch)lowerPitch).JustFrequency.Item1
                    };
                    return new JustIntonalPitchInterval(frequencyRatio, ReduceFraction(justRatio[0], justRatio[1]), centDifference);
                }
                else if ((((MidiPitch)higherPitch) != null) && (((MidiPitch)lowerPitch) != null)) {
                    //BasilMuguet.Log($"Created MidiIndex: {((MidiPitch)higherPitch).PitchIndex - midiPitchL.PitchIndex}");
                    return new MidiPitchInterval(frequencyRatio, ((MidiPitch)higherPitch).PitchIndex - ((MidiPitch)lowerPitch).PitchIndex, centDifference);
                }
                
                else if ((((CustomTETPitch)lowerPitch) != null) &&
                    (((CustomTETPitch)higherPitch) != null))
                {
                    if (((CustomTETPitch)lowerPitch).Base == ((CustomTETPitch)higherPitch).Base &&
                        ((CustomTETPitch)lowerPitch).TuningIndex == ((CustomTETPitch)higherPitch).TuningIndex &&
                        ((CustomTETPitch)lowerPitch).TuningFrequency == ((CustomTETPitch)higherPitch).TuningFrequency) {
                        return new CustomTETPitchInterval(frequencyRatio, ((CustomTETPitch)lowerPitch).Base, ((CustomTETPitch)higherPitch).PitchIndex - ((CustomTETPitch)lowerPitch).PitchIndex, centDifference: centDifference); 
                    }
                    else {
                        return new PitchInterval(frequencyRatio, centDifference: centDifference);
                    }
                }
            }
            else { // Different pitch types, compare their frequency ratio directly
                return new PitchInterval(frequencyRatio, centDifference: centDifference);
            }
            throw new InvalidOperationException("Unsupported pitch types.");
        }
        public static Pitch PitchIntervalToPitch(PitchInterval pitchInterval, Pitch pitch, bool inputPitchIsAbove){ //NOT DONE
            bool pitchTypeSame = pitchInterval.Type == pitch.Type;
            if (pitchTypeSame && pitch.Type == PitchType.TwelveToneEqual) {}
            else if (pitchTypeSame && pitch.Type == PitchType.CustomeToneEuqal) {}

            return null;}
        public static MidiPitchInterval PitchIntervalToMidiPitchInterval(PitchInterval pitchInterval) {
            int roundedPitchIndex = (int)CalculateHtzToMidiInterval(pitchInterval.FrequencyRatio);
            return new MidiPitchInterval(pitchInterval.FrequencyRatio, roundedPitchIndex, 0); // the frequency ratio is not made use of 
        }


        // Data Validation
        public static bool WINAIsValid(List<PitchInterval> WINA) {
            if (WINA == null) {return false;}
            int nodeCount = (int)Math.Floor(Math.Sqrt(2 * WINA.Count + 0.25) - 0.5); // not including the origin
            int correctValue = (int)Math.Floor(nodeCount * (nodeCount + 1) * 0.5f);
            return WINA.Count == correctValue;
        }


        // INA HANNDLING, ALLL OF EM HAVE TO BE AS EFFICIENT AS POSSIBLE, so reuse the same function as much as possible

        public static List<Pitch> PACToPOA(List<Pitch> PAC, Pitch Origin){PAC.Insert(0, Origin);return PAC;} //DONE
        public static List<Pitch> POAToPAC(List<Pitch> POA){POA.RemoveAt(0); return POA;} //DONE

        public static List<PitchInterval> PACToPSC(List<Pitch> PAC){ //DONE
            int listLength = PAC.Count;
            List<PitchInterval> PSC = new List<PitchInterval>();
            for (int a = 0; a < listLength; a++) {
                PitchInterval appendedInterval = CreatePitchInterval(PAC[0], PAC[a]);
                PSC.Add(appendedInterval);
            }
            return PSC;} 
        public static List<PitchInterval> POAToWINA(List<Pitch> POA){ //DONE
            int listLength = POA.Count;
            List<PitchInterval> WINA = new List<PitchInterval>();
            for (int a = 0; a < listLength; a++) {
                for (int b = 0; b < a; b++) {
                    PitchInterval appendedInterval = CreatePitchInterval(POA[b], POA[a]);
                    WINA.Add(appendedInterval);
                }
            }
            return WINA;} 
        public static List<PitchInterval> POAToSINA(List<Pitch> POA){ //DONE
            int listLength = POA.Count;
            List<PitchInterval> SINA = new List<PitchInterval>();
            for (int a = 0; a < listLength-1; a++) {
                PitchInterval appendedInterval = CreatePitchInterval(POA[a], POA[a+1]);
                SINA.Add(appendedInterval);
            }
            return SINA;} 
        public static List<PitchInterval> POAToPSINA(List<Pitch> POA){ //DONE
            int listLength = POA.Count;
            List<PitchInterval> PSINA = new List<PitchInterval>();
            for (int a = 1; a < listLength; a++) {
                PitchInterval appendedInterval = CreatePitchInterval(POA[0], POA[a]);
                PSINA.Add(appendedInterval);
            }
            return PSINA;
            } 

            //number of nodes excludes the origin. Return tuple returns (n0, n1) where n1 > n0. numberOfNodes disregard the origin
        public static List<Tuple<int, int>> CalculatePSCOrder(int numberOfNodes){ //DONE
            int listLength = numberOfNodes;
            List<Tuple<int, int>> PSCOrder = new List<Tuple<int, int>>();
            for (int i = 0; i < numberOfNodes;  i++){
                Tuple<int, int> appendedTuple = new Tuple<int, int>(0, i);
                PSCOrder.Add(appendedTuple);
            }
            return PSCOrder;
            }
        public static List<Tuple<int, int>> CalculateWINAOrder(int numberOfNodes){ //DONE
            int listLength = (int)Math.Floor(numberOfNodes * (numberOfNodes + 1) * 0.5f);
            List<Tuple<int, int>> WINAOrder = new List<Tuple<int, int>>();
            for (int a = 1; a < numberOfNodes + 1; a++){
                for (int b = 0; b < a; b++){
                    Tuple<int, int> appendedTuple = new Tuple<int, int>(b, a);
                    WINAOrder.Add(appendedTuple);
                }
            }
            return WINAOrder;
            }
        public static List<Tuple<int, int>> CalculateSINAOrder(int numberOfNodes){ //DONE
            int listLength = numberOfNodes;
            List<Tuple<int, int>> SINAORDER = new List<Tuple<int, int>>();
            for (int i = 0; i < numberOfNodes;  i++){
                Tuple<int, int> appendedTuple = new Tuple<int, int>(i, i+1);
                SINAORDER.Add(appendedTuple);
            }
            return SINAORDER;
            }
        public static List<Tuple<int, int>> CalculatePSINAOrder(int numberOfNodes){ //DONE
            int listLength = numberOfNodes;
            List<Tuple<int, int>> PSINAOrder = new List<Tuple<int, int>>();
            for (int i = 1; i < numberOfNodes+1;  i++){
                Tuple<int, int> appendedTuple = new Tuple<int, int>(0, i);
                PSINAOrder.Add(appendedTuple);
            }
            return PSINAOrder;
            }

        public static Tuple<int, int> CalculatePSCIndexResult(int index){return new Tuple<int, int>(0, index);} //DONE
        public static Tuple<int, int> CalculateWINAIndexResult(int index){ //DONE
            int n1 = (int)Math.Floor(Math.Sqrt(2 * index + 0.25) + 0.5);
            int n0 = index - (int)Math.Floor(n1 * (n1 - 1) * 0.5f);
            return new Tuple<int, int>(n0, n1);}
        public static Tuple<int, int> CalculateSINAIndexResult(int index){return new Tuple<int, int>(index, index+1);} //DONE
        public static Tuple<int, int> CalculatePSINAIndexResult(int index){return new Tuple<int, int>(0, index+1);} //DONE

        public static int CalculatePSCSize(int pulseCount) {return pulseCount;}
        public static int CalculateWINASize(int pulseCount) {return CalculateWINAIndex(0, pulseCount + 1);}
        public static int CalculateSINASize(int pulseCount) {return pulseCount + 1;}
        public static int CalculatePSINASize(int pulseCount) {return pulseCount + 1;}

        public static int CalculatePSCIndex(int n0, int n1){ //DONE
            if (n0 != 0) {return -1;}
            else {return n1;}
        }
        public static int CalculateWINAIndex(int n0, int n1){ //DONE
            return (int)Math.Floor(n1 * (n1 - 1) * 0.5f) + n0;} 
        public static int CalculateSINAIndex(int n0, int n1){ //DONE
            if (n0+1 != n1) {return -1;} 
            else {return n0;}
        }
        public static int CalculatePSINAIndex(int n0, int n1){ //DONE
            if (n0 != 0) {return -1;}
            else {return n1-1;}
        }

            // Efficienct INA to INA functions
        public static List<PitchInterval> WINAToSINA(List<PitchInterval> WINA){ //DONE
            int index;
            int nodeCount = (int)Math.Floor(Math.Sqrt(2 * WINA.Count + 0.25) - 0.5); // not including the origin
            List<PitchInterval> SINA = new List<PitchInterval>();
            for (int i = 1; i < nodeCount+1; i++) {
                index = (int)Math.Floor(i * (i + 1) * 0.5f) - 1;
                SINA.Add(WINA[index]);
            }

            return SINA;}
        public static List<PitchInterval> WINAToPSINA(List<PitchInterval> WINA){ //DONE
            int index;
            int nodeCount = (int)Math.Floor(Math.Sqrt(2 * WINA.Count + 0.25) - 0.5); // not including the origin  
            List<PitchInterval> PSINA = new List<PitchInterval>();
            for (int i = 0; i < nodeCount; i++) {
                index = (int)Math.Floor(i * (i + 1) * 0.5f);
                PSINA.Add(WINA[index]);
            }
            return PSINA;}

            // uh others. relating to PitchSet conversion specifically.
        public static List<PitchInterval> PSCToPSINA(List<PitchInterval> PSC, Pitch Origin){return null;} //NOT DONE
        public static List<PitchInterval> PSINAToPSC(List<PitchInterval> PSC){return null;} //NOT DONE

            // INA to PitchList Functions - NOT DONE
        public static List<Pitch> PSCToPOA(List<PitchInterval> PSC, Pitch Origin){return null;}
        public static List<Pitch> WINAToPOA(List<PitchInterval> WINA, Pitch Origin){ // DONE and Efficient
            return SINAToPOA(WINAToSINA(WINA), Origin);}
        public static List<Pitch> SINAToPOA(List<PitchInterval> SINA, Pitch Origin){return null;} //NOT DONE and not sure how to do
        public static List<Pitch> PSINAToPOA(List<PitchInterval> PSINA, Pitch Origin){return null;} //NOT DONE and not sure how to do

        public static List<Pitch> PSCToPAC(List<PitchInterval> PSC, Pitch Origin){return null;}
        public static List<Pitch> WINAToPAC(List<PitchInterval> WINA, Pitch Origin){ // DONE LMAO
            return SINAToPAC(WINAToSINA(WINA), Origin);}
        public static List<Pitch> SINAToPAC(List<PitchInterval> SINA, Pitch Origin){return null;} //NOT DONE and not sure how to do
        public static List<Pitch> PSINAToPAC(List<PitchInterval> PSINA, Pitch Origin){return null;} //NOT DONE and not sure how to do
        
        // WSCNI algorithm fast track changes in amount of pitches
            // Aim. Take an existing WINA and state to remove which node in POA terms (n1 to nN)) Then figure out how to reassemble the damn thing.
            // This is important because creating pitch interval takes alotta work, especially when there are meta data involved, so doing it as little as possible is better.
            // Additionally, the resonator will always update the amount in POA, which is a Hassle. So ontop of delaying, making this a lesser occurance helps as well.

        // tells you what to add / change / get rid of when you update WINA, but only works on singular entries
        public static List<int> IndexesToDeletedWINADeletePitch(int nodeCount, int pitchIndex) // first 2 entry is (count, range), the rest are normal indexes
        {
            List<int> indexesToBeDeleted = new List<int>{CalculateWINAIndex(0, pitchIndex), pitchIndex};
            for (int i = pitchIndex+1; i < nodeCount+1; i++) {
                indexesToBeDeleted.Add(CalculateWINAIndex(pitchIndex, i));
            }
            return indexesToBeDeleted;
        }
        public static List<Tuple<int, Tuple<int, int>>> IndexesToAddWINAAddPitch(int originalNodeCount, int pitchInsertionIndex) // List(index, Interval order(n0, n1))
        {
            List<Tuple<int, Tuple<int, int>>> returnList = new List<Tuple<int, Tuple<int, int>>>();
            BasilMuguet.Log($"ogNodeCount: {originalNodeCount} | insertionIndex: {pitchInsertionIndex}");

            // local variables
            int indexAdded;
            int constantM = CalculateWINAIndex(0,pitchInsertionIndex+1);

            // add rows
            for (int i = 0; i < pitchInsertionIndex+1; i++) {
                indexAdded = constantM + i;
                returnList.Add(new Tuple<int, Tuple<int, int>>(
                    indexAdded, new Tuple<int, int>
                    (i, pitchInsertionIndex) //n0, n1
                    ));
                BasilMuguet.Log($"AddedRow[{indexAdded}]: n{pitchInsertionIndex} -> n{i}");
            }
            // add the column - WHICH IS NOT WORKING??
            for (int i = 0; i < originalNodeCount-pitchInsertionIndex; i++) {
                indexAdded = CalculateWINAIndex(pitchInsertionIndex+1, pitchInsertionIndex+2+i);
                returnList.Add(new Tuple<int, Tuple<int, int>>(
                    indexAdded, new Tuple<int, int>
                    (pitchInsertionIndex, pitchInsertionIndex+1+i) //n0, n1
                    ));
                BasilMuguet.Log($"AddedCol[{indexAdded}]: n{pitchInsertionIndex+1+i} -> n{pitchInsertionIndex}");
            }
            return returnList;
        }
        
        // Here it even does it for you, with fast track on one of them, the other requiring a bit more finess.
        public static List<PitchInterval> WINADeletePitches // node are handled in POA form, aka you can't delete nodes at index 0 EVER
            (List<PitchInterval> WINA, List<int> nodesToBeDeletedList) { 
            int nodeCount = (int)Math.Floor(Math.Sqrt(2 * WINA.Count + 0.25) - 0.5); // not including the origin
            List<int> indexesToBeDeleted = new List<int>();
            // function local cache
            int tempIndex;
            for (int nodeToBeDeleted = 0; nodeToBeDeleted < nodesToBeDeletedList.Count; nodeToBeDeleted++) {
                tempIndex = CalculateWINAIndex(0, nodeToBeDeleted);
                for (int i = 0; i < nodeToBeDeleted; i++)
                {
                    indexesToBeDeleted.Add(tempIndex + i);
                }
                for (int i = nodeToBeDeleted+1; i < nodeCount+1; i++) {
                    indexesToBeDeleted.Add(CalculateWINAIndex(nodeToBeDeleted, i));
                }
            }
            // reassemble check and deleted repeted index and put it into newWINA
            List<PitchInterval> newWINA = new List<PitchInterval>();

            for (int i = 0; i < WINA.Count; i++) {
                if (!indexesToBeDeleted.Contains(i)) {
                    newWINA.Add(WINA[i]);
                }
            }
            return newWINA;}
        public static List<PitchInterval> WINAAddPitch // DONE
            (List<PitchInterval> originalWINA, List<Pitch> originalPOA, Pitch newPitch, int newPitchIndex) {
            // data validation 
            if (newPitchIndex > originalPOA.Count || newPitchIndex <= 0) {return null;} // newPitchIndex

            // insert the pitch into POA
            originalPOA.Insert(newPitchIndex, newPitch);
            
            // List(index, Interval order(n0, n1))
            List<Tuple<int, Tuple<int, int>>> listM = IndexesToAddWINAAddPitch(originalPOA.Count - 1, newPitchIndex);
            // interate accoridng to thy instructions
            PitchInterval localPitchInterval;
            foreach (Tuple<int, Tuple<int, int>> i in listM) {
                localPitchInterval = CreatePitchInterval(originalPOA[i.Item2.Item1], originalPOA[i.Item2.Item2]);
                originalWINA.Insert(i.Item1, localPitchInterval);
            }
            return originalWINA;
        }        
    }
}